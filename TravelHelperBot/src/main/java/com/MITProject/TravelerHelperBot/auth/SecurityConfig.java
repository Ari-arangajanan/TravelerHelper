package com.MITProject.TravelerHelperBot.auth;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.web.SecurityFilterChain;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import org.springframework.stereotype.Component;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.CorsConfigurationSource;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import java.util.Arrays;import java.util.List;@Component@EnableWebSecuritypublic class SecurityConfig {    private final JwtAuthenticationFilter jwtAuthenticationFilter;    private final CustomAuthenticationEntryPoint authenticationEntryPoint;    @Value("${telegram.bot.webApp}")    private String webAppUrl;    @Value("${telegram.bot.webhookPath}")    private String webhookUrl;    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter, CustomAuthenticationEntryPoint authenticationEntryPoint) {        this.jwtAuthenticationFilter = jwtAuthenticationFilter;        this.authenticationEntryPoint = authenticationEntryPoint;    }    @Bean    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity, CorsConfigurationSource corsConfigurationSource) throws Exception {        httpSecurity                .csrf(AbstractHttpConfigurer::disable)                .cors(cors -> cors.configurationSource(corsConfigurationSource))                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))                .authorizeHttpRequests(auth -> auth                        .requestMatchers("app/telegram/message").permitAll()                        .requestMatchers("/api/auth/**").permitAll()                        .requestMatchers("/api/serviceProvider/**").hasRole("SERVICEPROVIDER")                        .requestMatchers("/api/user/**").hasAnyRole("USER", "SERVICEPROVIDER")                        .anyRequest().authenticated()                )                .sessionManagement(session -> session                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // stateless session management                .exceptionHandling(exception -> exception                        .authenticationEntryPoint(authenticationEntryPoint)) // Ensure 401 is returned                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);        return httpSecurity.build();    }    @Bean    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {        return authenticationConfiguration.getAuthenticationManager();    }    @Bean    public CorsConfigurationSource corsConfigurationSource() {        CorsConfiguration corsConfiguration = new CorsConfiguration();        corsConfiguration.setAllowedOrigins(                Arrays.asList(                        "http://localhost:5175", webAppUrl,                        "https://**",                        webhookUrl,                        "https://*.telegram.org",                        "https://*.telegram.me"                ));        corsConfiguration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"));        corsConfiguration.setAllowedHeaders(List.of("*"));        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration("/**", corsConfiguration);        return source;    }    }