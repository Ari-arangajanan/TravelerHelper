package com.MITProject.TravelerHelperBot.auth;import org.springframework.context.annotation.Bean;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.web.SecurityFilterChain;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import org.springframework.stereotype.Component;@Componentpublic class SecurityConfig {    private final JwtAuthenticationFilter jwtAuthenticationFilter;    private final CustomAuthenticationEntryPoint authenticationEntryPoint;    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter, CustomAuthenticationEntryPoint authenticationEntryPoint) {        this.jwtAuthenticationFilter = jwtAuthenticationFilter;        this.authenticationEntryPoint = authenticationEntryPoint;    }    @Bean    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {        httpSecurity                .csrf(AbstractHttpConfigurer::disable)                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))                .authorizeHttpRequests(auth -> auth                        .requestMatchers("app/telegram/message").permitAll()                        .requestMatchers("/api/auth/**").permitAll()                        .requestMatchers("/api/serviceProvider/**").hasRole("SERVICEPROVIDER")                        .requestMatchers("/api/user/**").hasAnyRole("USER", "SERVICEPROVIDER")                        .anyRequest().authenticated()                )                .sessionManagement(session -> session                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // stateless session management                .exceptionHandling(exception -> exception                        .authenticationEntryPoint(authenticationEntryPoint)) // Ensure 401 is returned                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);        return httpSecurity.build();    }    @Bean    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {        return authenticationConfiguration.getAuthenticationManager();    }}