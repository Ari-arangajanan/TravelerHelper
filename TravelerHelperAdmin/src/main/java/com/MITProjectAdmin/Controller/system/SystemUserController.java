package com.MITProjectAdmin.Controller.system;import com.MITProjectAdmin.configs.JwtHelper;import com.MITProjectAdmin.configs.JwtResponseDTO;import com.MITProjectAdmin.security.AuthorizationService;import com.MITProjectAdmin.security.TokenBlacklistService;import com.MITProjectService.admin.dao.JpaRepos.specification.SysUserFilterSpecifications;import com.MITProjectService.admin.domain.system.RefreshToken;import com.MITProjectService.admin.domain.system.SysUser;import com.MITProjectService.admin.request.LoginRequest;import com.MITProjectService.admin.request.SystemUserRequest;import com.MITProjectService.admin.service.SysUserService;import com.MITProjectService.exceptionhandling.DataTransactionalException;import com.MITProjectService.framework.redis.RedisCashService;import com.MITProjectService.utils.DatabaseUtil;import com.fasterxml.jackson.core.JsonProcessingException;import jakarta.servlet.http.Cookie;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import jakarta.servlet.http.HttpSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataIntegrityViolationException;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.domain.Specification;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.security.authentication.BadCredentialsException;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.web.bind.annotation.*;import javax.validation.Valid;import java.time.Instant;import java.util.HashMap;import java.util.List;import java.util.Map;@CrossOrigin(origins = "http://localhost:5174", allowCredentials = "true")@RestController@RequestMapping(path = "/admin/systemUser")public class SystemUserController {    private static final long MINUTES = 60;    Logger logger = LoggerFactory.getLogger(SystemUserController.class);    @Autowired    public SystemUserController(SysUserService systemUserService, JwtHelper jwtHelper, PasswordEncoder passwordEncoder, AuthorizationService authorizationService, RedisCashService redisCashService, TokenBlacklistService tokenBlacklistService, DatabaseUtil databaseUtil) {        this.systemUserService = systemUserService;        this.jwtHelper = jwtHelper;        this.passwordEncoder = passwordEncoder;        this.authorizationService = authorizationService;        this.redisCashService = redisCashService;        this.tokenBlacklistService = tokenBlacklistService;        this.databaseUtil = databaseUtil;    }    private final SysUserService systemUserService;    private final JwtHelper jwtHelper;    private final PasswordEncoder passwordEncoder;    private final AuthorizationService authorizationService;    private final RedisCashService redisCashService;    private final TokenBlacklistService tokenBlacklistService;    private final DatabaseUtil databaseUtil;    @PostMapping(value = "/login")    public ResponseEntity<?> login(@Valid @RequestBody LoginRequest loginRequest, HttpServletResponse response) {        try {            Authentication authentication = authorizationService.authentication(loginRequest);            if (authentication.isAuthenticated()) {                RefreshToken refreshToken = authorizationService.createAndSaveRefreshToken(loginRequest);                String accessToken = jwtHelper.GenerateToken(loginRequest.getUserName());                boolean isAccessTokenSaved = authorizationService.saveAccessToken(loginRequest.getUserName(), refreshToken.getRefreshToken(), accessToken);                authorizationService.setRefreshTokenCookie(response, loginRequest, refreshToken);                JwtResponseDTO jwtResponse = JwtResponseDTO.builder()//                        .accessToken(accessToken)                        .refreshToken(refreshToken.getRefreshToken())                        .userName(loginRequest.getUserName())                        .build();                return ResponseEntity.ok(jwtResponse);            } else return ResponseEntity.status(HttpStatus.NOT_FOUND).body("user not found");        } catch (BadCredentialsException | UsernameNotFoundException e) {            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(e.getLocalizedMessage());        } catch (Exception e) {            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getLocalizedMessage());        }    }    @PostMapping(value = "/logout")    public ResponseEntity<String> logout(HttpServletRequest request, HttpServletResponse response) throws JsonProcessingException {        if (request.getCookies() != null) {            for (Cookie cookie : request.getCookies()) {                if (cookie.getName().equals("refreshToken")) {                    String refreshToken = cookie.getValue();                    String[] splitTxt = refreshToken.split(":");                    RefreshToken cashedRefreshToken = redisCashService.getRefreshToken("RefreshToken:" + refreshToken);                    boolean isRemoved = authorizationService.removeToken("RefreshToken:" + refreshToken);                    if (!isRemoved) throw new RuntimeException("errorInRemovingRefreshToken");                    String token = redisCashService.getAccessToken("accessToken:" + refreshToken);                    if (token == null || token.isEmpty()) {                        tokenBlacklistService.addToBlacklist(token);                    }                    boolean isRemovedAccessToken = authorizationService.removeToken("accessToken:" + refreshToken);                }            }            SecurityContextHolder.clearContext();            // Blacklist the JWT token            final String authorizationHeader = request.getHeader("Authorization");            if (authorizationHeader != null && authorizationHeader.startsWith("token ")) {                String jwtToken = authorizationHeader.substring(6);                tokenBlacklistService.addToBlacklist(jwtToken);            }            HttpSession session = request.getSession(false);            if (session != null) {                session.invalidate();            }            // Remove cookies            Cookie[] cookies = request.getCookies();            if (cookies != null) {                for (Cookie cookie : cookies) {                    cookie.setMaxAge(0);                    cookie.setValue(null);                    cookie.setPath("/");                    response.addCookie(cookie);                }            }            return ResponseEntity.ok("logout");        } else return ResponseEntity.status(HttpStatus.NOT_FOUND).body("no cookies found");    }    @RequestMapping(value = "/index", method = RequestMethod.POST)    public ResponseEntity<Map<String, Object>> index(@RequestBody SystemUserRequest systemUserRequest) {        Pageable pageable = PageRequest.of(systemUserRequest.getPage(), systemUserRequest.getLimit());        Specification<SysUser> specification = SysUserFilterSpecifications.findAndFilter(systemUserRequest);        // Fetch paginated data        Page<SysUser> sysUsers = systemUserService.findAll(specification, pageable);        // Fetch additional data (e.g., dropdown options)        List<Map<String, Object>> dropdownData = databaseUtil.getDropDownlist(                "user_role", List.of("id", "role") // Fetch all roles        );        Map<String, Object> response = new HashMap<>();        response.put("content",sysUsers);        response.put("dropdownData",dropdownData);        response.put("totalPages",sysUsers.getTotalPages());        response.put("totalElements",sysUsers.getTotalElements());        return ResponseEntity.ok(response);    }    @PostMapping(value = "/register")    public ResponseEntity<?> register(@RequestBody SystemUserRequest request) {        try {            request.setPassword(passwordEncoder.encode(request.getPassword()));            boolean isSaved = systemUserService.addSysUser(request);            if (isSaved) {                return ResponseEntity.status(HttpStatus.CREATED).body("success");            }            else return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(HttpStatus.INTERNAL_SERVER_ERROR);        } catch (DataIntegrityViolationException e) {            if (e.getRootCause() != null && e.getRootCause().getMessage().contains("Duplicate entry")) {                throw new DataTransactionalException("The username already exists. Please choose a different username.");            } else throw new DataTransactionalException(e.getLocalizedMessage());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    @PutMapping(value = "/updateUser")    public ResponseEntity<SysUser> updateUser(@RequestBody SysUser sysUser) {        try {            SysUser sysUserUpdate = systemUserService.updateSysUser(sysUser);            return ResponseEntity.ok(sysUserUpdate);        } catch (Exception e) {            throw new DataTransactionalException(e.getLocalizedMessage());        }    }    @DeleteMapping(value = "/deleteUser")    public ResponseEntity<String> deleteUser(@RequestParam("id") Long id) {        try {            boolean isDelete = systemUserService.deleteSysUser(id);            return ResponseEntity.status(HttpStatus.OK).body("deleted");        } catch (Exception e) {            throw new RuntimeException(e);        }    }    @RequestMapping(value = "/list", method = RequestMethod.GET)    public String list() {        return "list";    }    @PostMapping("/refresh")    public ResponseEntity<?> refreshToken(HttpServletRequest request, HttpServletResponse response) {        try {            // Extract refresh token from the cookie            Cookie[] cookies = request.getCookies();            if (cookies != null) {                for (Cookie cookie : cookies) {                    if ("refreshToken".equals(cookie.getName())) {                        String refreshToken = cookie.getValue();                        String[] parts = refreshToken.split(":");                        String userName = parts[0];                        String token = parts[1];                        // Validate and renew tokens                        RefreshToken cachedToken = redisCashService.getRefreshToken("RefreshToken:" + refreshToken);                        if (cachedToken != null && cachedToken.getExpiryDate().isAfter(Instant.now())) {                            String newAccessToken = jwtHelper.GenerateToken(userName);                            // Save new access token in Redis                            redisCashService.saveValInMin("accessToken:" + userName + ":" + token, newAccessToken, MINUTES);                            // Return new access token                            return ResponseEntity.ok(Map.of("accessToken", newAccessToken));                        } else {                            // Invalidate expired refresh token and clear cookie                            authorizationService.removeToken("RefreshToken:" + refreshToken);                            Cookie expiredCookie = new Cookie("refreshToken", null);                            expiredCookie.setHttpOnly(true);                            expiredCookie.setPath("/");                            expiredCookie.setMaxAge(0);                            response.addCookie(expiredCookie);                            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Refresh token expired");                        }                    }                }            }            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Refresh token missing");        } catch (Exception e) {            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error refreshing token: " + e.getMessage());        }    }}