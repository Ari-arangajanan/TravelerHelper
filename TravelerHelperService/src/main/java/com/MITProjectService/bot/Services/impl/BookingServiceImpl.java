package com.MITProjectService.bot.Services.impl;import com.MITProjectCommon.common.OrderIdGenerator;import com.MITProjectService.bot.Services.BookingService;import com.MITProjectService.bot.Services.PaymentService;import com.MITProjectService.bot.dao.jpaRepos.*;import com.MITProjectService.bot.domain.*;import com.MITProjectService.bot.enums.BookingStatusEnum;import com.MITProjectService.bot.enums.PaymentMethodEnum;import com.MITProjectService.bot.enums.PaymentServiceEnum;import com.MITProjectService.bot.enums.ServiceTypeEnums;import com.MITProjectService.bot.request.BookingRequest;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.domain.Specification;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.time.LocalDateTime;import java.util.Optional;@Servicepublic class BookingServiceImpl implements BookingService {    private final BookingServiceRepository bookingServiceRepository;    private final ServiceTypeRepository serviceTypeRepository;    private final UserRepository userRepository;    private final HiredServiceLogRepository hiredServiceLogRepository;    private final PaymentService paymentService;    public BookingServiceImpl(BookingServiceRepository bookingServiceRepository, ServiceTypeRepository serviceTypeRepository, UserRepository userRepository, HiredServiceLogRepository hiredServiceLogRepository,  PaymentService paymentService) {        this.bookingServiceRepository = bookingServiceRepository;        this.serviceTypeRepository = serviceTypeRepository;        this.userRepository = userRepository;        this.hiredServiceLogRepository = hiredServiceLogRepository;        this.paymentService = paymentService;    }    @Override    @Transactional    public Bookings submitBooking(BookingRequest request) {        try {            Optional<SnUser> user = userRepository.getUserByTelegramId(request.getUserTelegramIdId());            Optional<ServiceType> serviceType = serviceTypeRepository.findById(request.getServiceTypeId());            if (serviceType.isPresent() && serviceType.get().getStatus().equals(ServiceTypeEnums.INACTIVE.getValue())) {                throw new RuntimeException("Service Inactive");            }            if (user.isPresent() && serviceType.isPresent()) {                Bookings booking = new Bookings();                booking.setServiceType(serviceType.get());                booking.setUser(user.get());                booking.setBookingDateFrom(request.getBookingDateFrom());                booking.setBookingDateTo(request.getBookingDateTo());                booking.setStatus(BookingStatusEnum.PENDING.getValue());                booking.setOrderId(OrderIdGenerator.generateOrderId());                booking.setPrice(serviceType.get().getPrice());                serviceType.get().setStatus(ServiceTypeEnums.INACTIVE.getValue());                serviceTypeRepository.save(serviceType.get());// this is to ensure the service availability for the user                return bookingServiceRepository.save(booking);            }else return null;        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException("Error in BookingServiceImpl.submitBooking " + e.getMessage());        }    }    @Override    @Transactional    public Bookings bookingAcceptance(BookingRequest request) {        Optional<Bookings> booking = bookingServiceRepository.findById(request.getBookingId());        try{            if (booking.isPresent() && request.getStatus().equals(BookingStatusEnum.ACCEPTED)) {                if (booking.get().getStatus() != (BookingStatusEnum.PENDING.getValue())) {                    throw new RuntimeException("Booking already accepted");                }                booking.get().setStatus(BookingStatusEnum.ACCEPTED.getValue());                Payment payment = paymentState(booking.get());                payment = paymentService.saveOrUpdate(payment);                HiredServicesLog hiredServicesLog = hiredServicesLog(payment, booking.get());                hiredServiceLogRepository.save(hiredServicesLog);                return bookingServiceRepository.save(booking.get());            }else if(booking.isPresent() && request.getStatus().equals(BookingStatusEnum.REJECTED)){                if (booking.get().getStatus() != (BookingStatusEnum.PENDING.getValue()) && booking.get().getStatus() != (BookingStatusEnum.ACCEPTED.getValue())                    && booking.get().getStatus() != (BookingStatusEnum.REJECTED.getValue())) {                    throw new RuntimeException("Booking already accepted");                }                booking.get().setStatus(BookingStatusEnum.REJECTED.getValue());                booking.get().setRejectReason(request.getRejectReason());                booking.get().getServiceType().setStatus(ServiceTypeEnums.ACTIVE.getValue());                return bookingServiceRepository.save(booking.get());            }else if(booking.isPresent() && request.getStatus().equals(BookingStatusEnum.CANCELLED)){                booking.get().setStatus(BookingStatusEnum.CANCELLED.getValue());                booking.get().getServiceType().setStatus(ServiceTypeEnums.ACTIVE.getValue());                Optional<HiredServicesLog> hiredServicesLog = Optional.of(hiredServiceLogRepository.getByBookingId(booking.get().getId()));                hiredServicesLog.get().setStatus(BookingStatusEnum.CANCELLED.getValue());                Payment payment = paymentService.findByBookingId(booking.get().getId());                payment.setPaymentStatus(PaymentServiceEnum.CANCELLED.getValue());                paymentService.saveOrUpdate(payment);                hiredServiceLogRepository.save(hiredServicesLog.get());                return bookingServiceRepository.save(booking.get());            } else if(booking.isPresent() && request.getStatus().equals(BookingStatusEnum.COMPLETED)){                booking.get().getServiceType().setStatus(ServiceTypeEnums.ACTIVE.getValue());                booking.get().setStatus(BookingStatusEnum.COMPLETED.getValue());                Optional<HiredServicesLog> hiredServicesLog = Optional.of(hiredServiceLogRepository.getByBookingId(booking.get().getId()));                hiredServicesLog.get().setStatus(BookingStatusEnum.COMPLETED.getValue());                hiredServicesLog.get().getPayment().setPaymentStatus(PaymentServiceEnum.PENDING.getValue());                hiredServicesLog.get().setCompletedAt(LocalDateTime.now());                hiredServiceLogRepository.save(hiredServicesLog.get());                return bookingServiceRepository.save(booking.get());            }else return null;        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException("Error in BookingServiceImpl.updateBookingStatus " + e.getMessage());        }    }    private HiredServicesLog hiredServicesLog(Payment payment, Bookings bookings) {        HiredServicesLog hiredServicesLog = new HiredServicesLog();        hiredServicesLog.setUser(bookings.getUser());        hiredServicesLog.setHiredAt(bookings.getBookingDateFrom());        hiredServicesLog.setCompletedAt(bookings.getBookingDateTo());        hiredServicesLog.setServiceProvider(bookings.getServiceType().getServiceRegistration().getServices().getServiceProvider());        hiredServicesLog.setBooking(bookings);        hiredServicesLog.setPayment(payment);        hiredServicesLog.setServiceName(bookings.getServiceType().getTypeName());        hiredServicesLog.setPrice(bookings.getPrice());        hiredServicesLog.setStatus(BookingStatusEnum.ACCEPTED.getValue());        hiredServicesLog.setOrderId(bookings.getOrderId());        return hiredServicesLog;    }    private Payment paymentState(Bookings booking) {        Payment payment = new Payment();        payment.setBooking(booking);        payment.setAmount(booking.getPrice());        payment.setPaymentOrderId(booking.getOrderId());        payment.setPaymentMethod(PaymentMethodEnum.PENDING.getName());        payment.setPaymentGateway(PaymentMethodEnum.PENDING.getName());        payment.setPaymentStatus(PaymentServiceEnum.PENDING.getValue());        return payment;    }    @Override    public Bookings getBookingById(Long id) {        Optional<Bookings> booking = bookingServiceRepository.findById(id);        return booking.get();    }    @Override    public Page<Bookings> getAllBookingsPage(Pageable pageable, Specification<Bookings> specification) {        try {            return bookingServiceRepository.findAll(specification, pageable);        } catch (Exception e) {            e.printStackTrace();            System.out.println("Error in BookingServiceImpl.getAllBookingsPage " + e.getMessage());            throw new RuntimeException("Error in BookingServiceImpl.getAllBookingsPage " + e.getMessage());        }    }}