package com.MITProjectService.bot.Services.impl;import com.MITProjectService.bot.Services.ServiceCategoryService;import com.MITProjectService.bot.Services.ServiceRegistrationService;import com.MITProjectService.bot.dao.jpaRepos.ServiceCategoryRepository;import com.MITProjectService.bot.dao.jpaRepos.ServiceProviderRepository;import com.MITProjectService.bot.dao.jpaRepos.ServiceRegistrationRepository;import com.MITProjectService.bot.dao.jpaRepos.ServicesRepository;import com.MITProjectService.bot.domain.*;import com.MITProjectService.bot.enums.ServiceRegistrationEnum;import com.MITProjectService.bot.enums.ServiceStateEnum;import com.MITProjectService.bot.request.dto.*;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.domain.Specification;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.time.LocalDateTime;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.function.Function;import java.util.stream.Collectors;@Servicepublic class ServiceRegistrationServiceImpl implements ServiceRegistrationService {    private final ServiceRegistrationRepository serviceRegistrationRepository;    private final ServiceProviderRepository serviceProviderRepository;    private final ServicesRepository serviceRepository;    private final ServiceCategoryRepository serviceCategoryRepository;    public ServiceRegistrationServiceImpl(ServiceRegistrationRepository serviceRegistrationRepository, ServiceProviderRepository serviceProviderRepository, ServicesRepository serviceRepository, ServiceCategoryService serviceCategoryService, ServiceCategoryRepository serviceCategoryRepository) {        this.serviceRegistrationRepository = serviceRegistrationRepository;        this.serviceProviderRepository = serviceProviderRepository;        this.serviceRepository = serviceRepository;        this.serviceCategoryRepository = serviceCategoryRepository;    }    @Override    @Transactional    public ServiceRegistration submitServiceRegistration(ServiceRegistrationDTO dto) {        try {            // Validate provider exists            ServiceProvider serviceProvider = serviceProviderRepository.findById(dto.getServiceProviderId())                    .orElseThrow(() -> new IllegalArgumentException("Invalid Services Provider ID"));            // Create mappers converters for the DTOs to Entities using Java 8 functions            Function<ServiceTypeDTO, ServiceType> mapServiceTypeFn = creaetServiceTypeMapper();            Function<AttributeDTO, ServiceAttribute> mapServiceAttributeFn = creaetServiceAttributeMapper();            Function<PricingRuleDTO, PricingRuleRegistration> mapPricingRuleFn = creaetPricingRuleMapper();            // Create and save registration            ServiceRegistration registration = new ServiceRegistration();            registration.setServiceName(dto.getServiceName());            registration.setDescription(dto.getDescription());            registration.setCategoryId(dto.getCategoryId());            registration.setBasePrice(dto.getBasePrice());            registration.setLatitude(dto.getLatitude());            registration.setLongitude(dto.getLongitude());            registration.setStatus(ServiceRegistrationEnum.PENDING.getVal());            registration.setRegistrationDate(java.time.LocalDateTime.now());            registration.setRegisteredBy(serviceProvider);//            registration = serviceRegistrationRepository.save(registration);//            ServiceRegistration finalRegistration = registration;            // create and fix the service types            List<ServiceType> serviceTypes = dto.getServiceTypeRegistrations().stream().map(                    serviceTypeDTO -> {                        ServiceType serviceType = mapServiceTypeFn.apply(serviceTypeDTO);                        serviceType.setServiceRegistration(registration);                        serviceType.setServiceAttributes(serviceTypeDTO.getServiceAttributeRegistrations().stream().map(                                mapServiceAttributeFn                        ).peek(attribute-> attribute.setServiceType(serviceType))// link to [parent] service type                                .collect(Collectors.toList()));                        serviceType.setPricingRuleRegistrations(serviceTypeDTO.getPricingRuleRegistrations().stream().map(mapPricingRuleFn)                                .peek(pricingRule -> pricingRule.setServiceType(serviceType)) // link to [parent] service type                                .collect(Collectors.toList()));                        return serviceType;                    }).collect(Collectors.toList());            registration.setServiceTypes(serviceTypes);            return serviceRegistrationRepository.save(registration);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    private Function<PricingRuleDTO, PricingRuleRegistration> creaetPricingRuleMapper() {        return pricingRuleDTO -> {            PricingRuleRegistration pricingRuleRegistration = new PricingRuleRegistration();            pricingRuleRegistration.setPricingType(pricingRuleDTO.getPricingType());            pricingRuleRegistration.setPrice(pricingRuleDTO.getPrice());            pricingRuleRegistration.setStartDate(pricingRuleDTO.getStartDate());            pricingRuleRegistration.setEndDate(pricingRuleDTO.getEndDate());            return pricingRuleRegistration;        };    }    private Function<AttributeDTO, ServiceAttribute> creaetServiceAttributeMapper() {        return attributeDTO -> {            ServiceAttribute serviceAttribute = new ServiceAttribute();            serviceAttribute.setAttributeName(attributeDTO.getAttributeName());            serviceAttribute.setAttributeValue(attributeDTO.getAttributeValue());            return serviceAttribute;        };    }    private Function<ServiceTypeDTO, ServiceType> creaetServiceTypeMapper() {        return serviceTypeDTO -> {            ServiceType serviceType = new ServiceType();            serviceType.setTypeName(serviceTypeDTO.getTypeName());            serviceType.setDescription(serviceTypeDTO.getDescription());            serviceType.setPrice(serviceTypeDTO.getPrice());            serviceType.setCapacity(serviceTypeDTO.getCapacity());            return serviceType;        };    }    @Override    public Page<ServiceRegistration> getAllRegistrations(Pageable pageable, Long providerId) {        return serviceRegistrationRepository.findByProviderId(providerId, pageable);    }    @Override    public ServiceRegistration getRegistrationDetails(Long registrationId) {        return serviceRegistrationRepository.getReferenceById(registrationId);    }    @Override    public Page<ServiceRegistration> getAllRegistrationsPage(Pageable pageable, Specification<ServiceRegistration> specification) {        return serviceRegistrationRepository.findAll(specification, pageable);    }    @Override    public Map<String, ?> updateRegistrationStatus(RegistrationApprovalDTO dto) {        Map<String, Object> returnStatement = new HashMap<>();        // Fetch the ServiceRegistrationEnum        ServiceRegistration registration = serviceRegistrationRepository.findById(dto.getRequestId())                .orElseThrow(() -> new IllegalArgumentException("Registration not found"));        if (ServiceRegistrationEnum.APPROVED.equals(ServiceRegistrationEnum.valueOf(dto.getStatus().toUpperCase()))) {            if (registration.getStatus() != ServiceRegistrationEnum.PENDING.getVal()) {                throw new IllegalArgumentException("Registration already approved");            }            // Create a new Services entity            Services services = new Services();            services.setServiceName(registration.getServiceName());            services.setDescription(registration.getDescription());            services.setCategory(serviceCategoryRepository.getReferenceById(registration.getCategoryId()));            services.setBasePrice(registration.getBasePrice());            services.setLatitude(registration.getLatitude());            services.setLongitude(registration.getLongitude());            services.setServiceProvider(registration.getRegisteredBy());            services.setStatus(ServiceStateEnum.ENABLED.getVal()); // Active            services = serviceRepository.save(services);            // Update ServiceRegistration with the created Services and Approval info            registration.setServices(services);            registration.setStatus(ServiceRegistrationEnum.APPROVED.getVal()); // Approved            registration.setApprovalDate(LocalDateTime.now());            serviceRegistrationRepository.saveAndFlush(registration);            // return Status            returnStatement.put("status", ServiceRegistrationEnum.fromString(dto.getStatus()));            returnStatement.put("servicesRegistrationId", registration.getId());        }// Handle Rejection        else if (ServiceRegistrationEnum.REJECTED.equals(ServiceRegistrationEnum.valueOf(dto.getStatus().toUpperCase()))) {            if (registration.getStatus() != 0) {                throw new IllegalStateException("Only Pending registrations can be rejected");            }            registration.setStatus(ServiceRegistrationEnum.REJECTED.getVal()); // Rejected            registration.setApprovalDate(LocalDateTime.now());            registration.setRejectReason(dto.getReason() != null ? dto.getReason() : "No reason provided");            // return Status            returnStatement.put("status", ServiceRegistrationEnum.fromString(dto.getStatus()));            returnStatement.put("servicesRegistrationId", registration.getId());        } else {            throw new IllegalArgumentException("Invalid status. Use 'Approved' or 'Rejected'.");        }        return returnStatement;    }}